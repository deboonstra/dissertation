---
title: "Simulations investigating the correlation structure selection properties for mCIC(R) using Occam's Window"
subtitle: "given a randomly generated sampling distribution"
author: "D. Erik Boonstra, MS"
output:
  html_document:
    toc: TRUE
    toc_depth: 2
    toc_float: TRUE
---

```{r, include = FALSE, results = FALSE, message = FALSE}
R <- list.files(path = "./R", pattern = "*.R", full.names = TRUE)
sapply(R, source, .GlobalEnv)
knitr::opts_chunk$set(
  echo = FALSE,
  out.width = "100%",
  fig.align = "center",
  warning = FALSE
)
```

# Purpose of simulations
The results of these simulations are to investigate the correlation structure selection properties of modified CIC(R), or known as mCIC(R).

# Definition of mCIC(R)
Let $R(\alpha) = R$ be the working correlation structure, $\hat{\boldsymbol{\beta}}(R)$ be mean parameter estimator given $R$. Furthermore, let the model-based estimated covariance matrix of $\hat{\boldsymbol{\beta}}$ be $\hat{\boldsymbol{\Sigma}}$ and the robust or sandwich estimated covariance matrix of $\hat{\boldsymbol{\beta}}$ be $\hat{\mathbf{V}}_{r}$. Then, following from Hardin and Hilbe, we have

$$
mCIC(R) = trace\left(\hat{\boldsymbol{\Omega}}_{R\mid \hat{\boldsymbol{\beta}} = \hat{\boldsymbol{\beta}}(R)}\hat{\mathbf{V}}_{r\mid \hat{\boldsymbol{\beta}} = \hat{\boldsymbol{\beta}}(R)}\right),
$$

where $\hat{\boldsymbol{\Omega}} = \hat{\boldsymbol{\Sigma}}^{-1}$.

# Occam's window
The correlation structure that produced a value within Occam's window and has the minimum number of correlation parameters estimated is the correlation structured selected.

# Simulation setup

## Data
```{r, include = FALSE}
nsims <- 1000L
beta <- c(2.0, 3.0, 0.5, 0, 0, 0)
w <- which(beta != 0)
l <- length(w)
N <- c(rep(200, 7), 300, 240, 150, 120, 100, 80, 75)
n <- c(4, 5, 6, 7, 8, 9, 10, 4, 5, 8, 10, 12, 15, 16)
names_work_corstr <- c(
  "independence",
  "exchangeable",
  "ar1",
  "ar3",
  "unstructured"
)
mv <- c(1, 1, 1, 3, 1)
legend_work_corstr <- paste0(
  toupper(substr(names_work_corstr, 1, 1)),
  substr(names_work_corstr, 2, nchar(names_work_corstr))
)
legend_work_corstr <- ifelse(
  test = legend_work_corstr == "Ar1",
  yes = "AR(1)",
  no = legend_work_corstr
)
legend_work_corstr <- ifelse(
  test = legend_work_corstr == "Ar3",
  yes = "AR(3)",
  no = legend_work_corstr
)
```

Following Wang *et al.* (2012) with one-thousand replications, the correlated normal responses are generated from the model $$y_{ij} = \mathbf{X}_{ij}^{\top}\boldsymbol{\beta} + \varepsilon_{ij},$$ where $i = 1, \ldots, N,$ $j = 1, \ldots, n,$ $\mathbf{X}_{ij} = (x_{ij, 1}, \ldots, x_{ij, 6})^{\top},$ and $\boldsymbol{\beta} = (2.0, 3.0, 0.5, 0.0, 0.0, 0.0)^{\top}$, where the combinations of $N$ and $n$ are listed below.

```{r, echo = FALSE}
all_combos <- data.frame(N = N, n = n)
tab <- knitr::kable(
  x = all_combos,
  format = "html",
  col.names = c("$N$", "$n$")
)
kableExtra::kable_styling(
  kable_input = tab,
  full_width = FALSE
)
```

- For the covariates,
    - $x_{ij,1}$ was generated from the Bernoulli(0.5) distribution, and 
    - each $x_{ij,k}$ for $k = 2, \ldots, 6$ was generated from the multivariate normal distribution with mean 0 and an AR(1) covariance matrix with marginal variance 1 and auto-correlation coefficient 0.5.
- The random errors $(\varepsilon_{i1}, \ldots, \varepsilon_{in})^{\top}$ are generated from the multivariate normal distribution with marginal mean 0, marginal variance 1, and either an **exchangeable** or **AR(1)** correlation structure with a correlation parameter of $\alpha = 0.5$.

## Fitting procedure
Considering the focus of these simulations are on the correlation structure selection, each model, based on data generated by an **exchangeable** or **AR(1)** correlation structure, was fitted using generalized estimating equations. The mean structure was properly specified as $\mathbf{X}_{1}$, $\mathbf{X}_{2}$, and $\mathbf{X}_{3}$ with an intercept that was estimated to be approximately 0. To assess the correlation structure selection properties, the working correlation structure was specified as:

- independence,
- exchangeable,
- AR(1),
- AR(3), and
- unstructured.

## Model selection process
In these simulations, there are four sets of comparisons being made between the four correlation structures. These comparisons are:

1. exchangeable versus AR(1),
2. exchangeable versus AR(1) versus independence,
3. exchangeable versus AR(1) versus independence versus AR(3), and
4. exchangeable versus AR(1) versus independence versus AR(3) versus unstructured.

We are making these comparisons because previous research usually only focuses on exchangeable and AR(1). As these simulations are meant to investigate the selection properties of mCIC(R), for each comparison, the correlation structure that resulted in the minimum number of correlation parameters estimated that has a $mCIC(R)$ value within Occam's window based on the theortical idea value of $mCIC(R)_{ideal} =$ `r l + 1` was selected as the best performing correlation structure. Occam's window was defined by calculating the 90th percentile of the sampling distribution of $mCIC(R)$.Additionally, Occam's window was implemented for each comparison outline above. Considering the exchangeable and AR(1) correlation structures have identical number of correlation parameters estimated, the correlation structure that has the minimum $\widehat{mCIC(R)}$ value will be selected.

- Additionally, if there are no criterion values that fall within Occam's window, then the correlation structure associated with the minimum $\widehat{mCIC(R)}$ is selected.

### Sampling distribution of $mCIC(R)$
In defining Occam's window for each of the model selection comparisons, the sampling distribution of $mCIC(R)$ was used. In these simulations, prior to peforming any model selection procedure the sampling distribution of $mCIC(R)$ was approximated by randomly generating 1,000 data sets assuming within-subject independence and obtaining $\widehat{mCIC(R)}$ for the largest correlation structure under consideration.

- For the first comparison, a sampling distribution was not generated, as exchangeable and AR(1) correlation structures have the same number of correlation parameters. So, Occam's window does not need to be implemented.
- However, for the second comparison, the inclusion of the independence correlation structure requires the implementation of Occam's window. Thus, the sampling distribution is generated by obtaining the $\widehat{mCIC(R)}$ for the generating correlation structure. This does provide an optimistic representation of this method, as the sampling distribution is based on unknown practical information. A justification for this method would be the within-subject sample correlation matrices can be obtained prior to any model estimation, and there is a drastic difference in appearance between the exchangeable and AR(1) correlation structures.
- For the third and fourth model selection comparisons, the sampling distributions are based on the AR(3) and unstructured correlation structures, respectively, as those are the largest correlation structures under consideration. 
- Currently, the randomly generated data is based on the same data generation mechanism that the simulations are based on, except there is no within-subject correlation. This provides another optimistic representation of this method, but is a good starting place.
  - For these simulations, $\mathbf{X}$ and $\mathbf{y}$ are generated by the same data generation mechanism outlined above, where the appropriate $\boldsymbol{\beta}$ was used to generate $\mathbf{y}$
  - In the future, we can use a method that completely generates random data, where only the $N$, $n$, and $p$ are provided.

# Presentation of results

## Import results
The simulation results are stored in:
```{r, echo = TRUE}
sub_dir <- "./outputs/corstr/norm-modified-cic-sim/norm-modified-cic-occam-gen-samp-sim/" #nolint
res <- readRDS(
  file = paste0(sub_dir, "norm_modified_cic_occam_gen_samp_sim.rds")
)
```

```{r, include = FALSE}
# indices for all N and n values
fixed_n <- 1:7
fixed_obs <- c(8:9, 3, 10:14)
```

```{r, include = FALSE}
# creating a function to plot histograms
plot_all <- function(data, index, min_val) {
  # Subsetting the results to only include the results of focus based on index
  res_plot <- data
  res_plot$group <- paste0("N = ", res_plot$N, ", n = ", res_plot$n)
  group_id <- paste0("N = ", N[index], ", n = ", n[index])
  res_plot <- subset(x = res_plot, subset = res_plot$group %in% group_id)
  res_plot$group <- factor(
    x = res_plot$group,
    levels = group_id,
    ordered = TRUE
  )

  # plotting mCIC values

  ## Independence
  independence_plot <- ggplot2::ggplot(
    data = res_plot,
    mapping = ggplot2::aes(x = independence, fill = group)
  ) +
    ggplot2::geom_density(alpha = 0.5, color = NA) +
    ggplot2::geom_vline(
      xintercept = min_val, linetype = "dotted", color = "firebrick",
      linewidth = 1
    ) +
    ggplot2::labs(
      x = "mCIC(R)",
      y = "Density",
      title = "Working correlation: Independence"
    ) +
    ggplot2::guides(fill = ggplot2::guide_legend(title = "N =, n =")) +
    ggplot2::theme_bw() +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 10))

  ## Exchangeable
  exchangeable_plot <- ggplot2::ggplot(
    data = res_plot,
    mapping = ggplot2::aes(x = exchangeable, fill = group)
  ) +
    ggplot2::geom_density(alpha = 0.5, color = NA) +
    ggplot2::geom_vline(
      xintercept = min_val, linetype = "dotted", color = "firebrick",
      linewidth = 1
    ) +
    ggplot2::labs(
      x = "mCIC(R)",
      y = "Density",
      title = "Working correlation: Exchangeable"
    ) +
    ggplot2::guides(fill = ggplot2::guide_legend(title = "N =, n =")) +
    ggplot2::theme_bw() +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 10))

  ## AR(1)
  ar1_plot <- ggplot2::ggplot(
    data = res_plot,
    mapping = ggplot2::aes(x = ar1, fill = group)
  ) +
    ggplot2::geom_density(alpha = 0.5, color = NA) +
    ggplot2::geom_vline(
      xintercept = min_val, linetype = "dotted", color = "firebrick",
      linewidth = 1
    ) +
    ggplot2::labs(
      x = "mCIC(R)",
      y = "Density",
      title = "Working correlation: AR(1)"
    ) +
    ggplot2::guides(fill = ggplot2::guide_legend(title = "N =, n =")) +
    ggplot2::theme_bw() +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 10))

  ## AR(3)
  ar3_plot <- ggplot2::ggplot(
    data = res_plot,
    mapping = ggplot2::aes(x = ar3, fill = group)
  ) +
    ggplot2::geom_density(alpha = 0.5, color = NA) +
    ggplot2::geom_vline(
      xintercept = min_val, linetype = "dotted", color = "firebrick",
      linewidth = 1
    ) +
    ggplot2::labs(
      x = "mCIC(R)",
      y = "Density",
      title = "Working correlation: AR(3)"
    ) +
    ggplot2::guides(fill = ggplot2::guide_legend(title = "N =, n =")) +
    ggplot2::theme_bw() +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 10))

  ## Unstructured
  unstructured_plot <- ggplot2::ggplot(
    data = res_plot,
    mapping = ggplot2::aes(x = unstructured, fill = group)
  ) +
    ggplot2::geom_density(alpha = 0.5, color = NA) +
    ggplot2::geom_vline(
      xintercept = min_val, linetype = "dotted", color = "firebrick",
      linewidth = 1
    ) +
    ggplot2::labs(
      x = "mCIC(R)",
      y = "Density",
      title = "Working correlation: Unstructured"
    ) +
    ggplot2::guides(fill = ggplot2::guide_legend(title = "N =, n =")) +
    ggplot2::theme_bw() +
    ggplot2::theme(plot.title = ggplot2::element_text(hjust = 0.5, size = 10))
  ggpubr::ggarrange(
    independence_plot, exchangeable_plot, ar1_plot, ar3_plot,
    unstructured_plot,
    ncol = 2, nrow = 3, common.legend = TRUE, legend = "right"
  )
}
```

```{r, include = FALSE}
# creating functions to calculate statistics

## mean
mean_all <- function(data, index) {
  # Subsetting the results to only include the results of focus based on index
  res_plot <- data
  res_plot$group <- paste0("N = ", res_plot$N, ", n = ", res_plot$n)
  group_id <- paste0("N = ", N[index], ", n = ", n[index])
  res_plot <- subset(x = res_plot, subset = res_plot$group %in% group_id)
  res_plot$group <- factor(
    x = res_plot$group,
    levels = group_id,
    ordered = TRUE
  )
  # Creating table
  mean_tab <- dplyr::group_by(.data = res_plot, group)
  mean_tab <- dplyr::summarise(
    .data = mean_tab,
    independence = mean(independence),
    exchangeable = mean(exchangeable),
    ar1 = mean(ar1),
    ar3 = mean(ar3),
    unstructured = mean(unstructured),
    mcic0 = mean(mcic0)
  )
  mean_tab <- knitr::kable(
    x = mean_tab, format = "html", digits = 3,
    col.names = c("N =, n =", legend_work_corstr, "$mCIC(R)_{0}$"),
    caption = "Mean of values"
  )
  kableExtra::kable_styling(kable_input = mean_tab, full_width = FALSE)
}

## variance
variance_all <- function(data, index) {
  # Subsetting the results to only include the results of focus based on index
  res_plot <- data
  res_plot$group <- paste0("N = ", res_plot$N, ", n = ", res_plot$n)
  group_id <- paste0("N = ", N[index], ", n = ", n[index])
  res_plot <- subset(x = res_plot, subset = res_plot$group %in% group_id)
  res_plot$group <- factor(
    x = res_plot$group,
    levels = group_id,
    ordered = TRUE
  )
  # Creating table
  var_tab <- dplyr::group_by(.data = res_plot, group)
  var_tab <- dplyr::summarise(
    .data = var_tab,
    independence = stats::var(independence),
    exchangeable = stats::var(exchangeable),
    ar1 = stats::var(ar1),
    ar3 = stats::var(ar3),
    unstructured = stats::var(unstructured),
    mcic0 = stats::var(mcic0)
  )
  var_tab <- knitr::kable(
    x = var_tab, format = "html", digits = 3,
    col.names = c("N =, n =", legend_work_corstr, "$mCIC(R)_{0}$"),
    caption = "Variance of values"
  )
  kableExtra::kable_styling(kable_input = var_tab, full_width = FALSE)
}
```

and are dependent on the data generation mechanism (`corstr`).

## Distribution of mCIC(R) {.tabset .tabset-fade}
The first set of results being presented are the values of mCIC(R) for each working correlation structure across the one-thousand replications given the data generation mechanism. The results are presented based on the data simulation process (i.e., *Fixed N* or *Fixed total number of observations*).

The averages and variances of the oracle values of mCIC(R), $mCIC(R)_{0}$ is presented along side the averages and variances of statistics. The $mCIC(R)_{0}$ is defined as

$$
mCIC(R)_{0} = trace\left(\hat{\boldsymbol{\Omega}}_{min\mid \hat{\boldsymbol{\beta}} = \hat{\boldsymbol{\beta}}(R)}\boldsymbol{\Sigma}_{0}\right),
$$

where $\hat{\boldsymbol{\Omega}}_{min}$ is the inverse of the model-based covariance matrix associated with the working correlation matrix that produced the minimum mCIC(R) statistic and $\boldsymbol{\Sigma}_{0}$ is the estimated true covariance matrix.

### Generating correlation structure: Exchangeable
The distributions of the mCIC(R) presented below are based on the data generation process that used an *exchangeable* correlation structure.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include generating correlation structure
res_mcic <- subset(
  x = res,
  subset = corstr == "exchangeable"
)
```

#### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# plotting mCIC values
plot_all(data = res_mcic, index = fixed_n, min_val = l + 1)

# table summarizing mCIC values
## Mean
mean_all(data = res_mcic, index = fixed_n)

## Variance
variance_all(data = res_mcic, index = fixed_n)
```


#### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# plotting mCIC values
plot_all(data = res_mcic, index = fixed_obs, min_val = l + 1)

# table summarizing mCIC values
## Mean
mean_all(data = res_mcic, index = fixed_obs)

## Variance
variance_all(data = res_mcic, index = fixed_obs)
```


### Generating correlation structure: AR(1)
The distributions of the mCIC(R) presented below are based on the data generation process that used an *AR(1)* correlation structure.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include generating correlation structure
res_mcic <- subset(
  x = res,
  subset = corstr == "ar1"
)
```

#### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# plotting mCIC values
plot_all(data = res_mcic, index = fixed_n, min_val = l + 1)

# table summarizing mCIC values
## Mean
mean_all(data = res_mcic, index = fixed_n)

## Variance
variance_all(data = res_mcic, index = fixed_n)
```


#### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# plotting mCIC values
plot_all(data = res_mcic, index = fixed_obs, min_val = l + 1)

# table summarizing mCIC values
## Mean
mean_all(data = res_mcic, index = fixed_obs)

## Variance
variance_all(data = res_mcic, index = fixed_obs)
```

## Correlation structure selection {.tabset .tabset-fade}
Now we will examine the selection properties of mCIC(R) given the generating correlation structure and working correlation structures being compared. The comparisons are:

1. exchangeable versus AR(1),
2. exchangeable versus AR(1) versus independence, and
3. exchangeable versus AR(1) versus independence versus AR(3), and
4. exchangeable versus AR(1) versus independence versus AR(3) versus unstructured.

and the results are presented based on the defined numbering system of these comparisons. For each comparison, the hope is the working correlation structure selected by the Occam's window is the generating correlation structure the majority of the time.
```{r, echo = FALSE}
corstr_count <- function(x) {
  count_indp <- 0
  count_cs <- 0
  count_ar1 <- 0
  count_ar3 <- 0
  count_un <- 0
  count_na <- 0
  for (i in seq_along(x)) {
    if (!is.na(x[i])) {
      count_indp <- count_indp + (x[i] == "independence")
      count_cs <- count_cs + (x[i] == "exchangeable")
      count_ar1 <- count_ar1 + (x[i] == "ar1")
      count_ar3 <- count_ar3 + (x[i] == "ar3")
      count_un <- count_un + (x[i] == "unstructured")
    } else {
      count_na <- count_na + is.na(x[i])
    }
  }
  temp <- data.frame(
    independence = count_indp, exchangeable = count_cs,
    ar1 = count_ar1, ar3 = count_ar3, un = count_un,
    count_na = count_na
  )
  return(temp)
}
```

### Generating correlation structure: Exchangeable {.tabset .tabset-fade .tabset-pills}
The selection properties of the mCIC(R) presented below are based on the data generation process that used an *exchangeable* correlation structure.

```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include generating correlation structure
# and covariance estimator of interest
res_mcic <- subset(
  x = res,
  subset = corstr == "exchangeable"
)
```

#### Comparison 1

For structure selection comparison 1, we are only considering the working correlation structures of *exchangeable* and *AR(1)*.

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel1)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```


##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel1)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

#### Comparison 2

For structure selection comparison 2, we are only considering the working correlation structures of *independence*, *exchangeable*, and *AR(1)*.

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel2)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```


##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel2)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

#### Comparison 3

For structure selection comparison 1, we are considering all the working correlation structures of *independence*, *exchangeable*, *AR(1)*, and *AR(3)*.

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel3)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```


##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel3)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

#### Comparison 4

For structure selection comparison 1, we are considering all the working correlation structures of *independence*, *exchangeable*, *AR(1)*, *AR(3)*, and "unstructured".

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel4)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel4)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

### Generating correlation structure: AR(1) {.tabset .tabset-fade .tabset-pills}
The selection properties of the mCIC(R) presented below are based on the data generation process that used an *AR(1)* correlation structure.

```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include generating correlation structure
# and covariance estimator of interest
res_mcic <- subset(
  x = res,
  subset = corstr == "ar1"
)
```

#### Comparison 1

For structure selection comparison 1, we are only considering the working correlation structures of *exchangeable* and *AR(1)*.

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel1)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```


##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel1)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

#### Comparison 2

For structure selection comparison 2, we are only considering the working correlation structures of *independence*, *exchangeable*, and *AR(1)*.

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel2)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```


##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel2)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

#### Comparison 3

For structure selection comparison 1, we are considering all the working correlation structures of *independence*, *exchangeable*, *AR(1)*, and *AR(3)*.

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel3)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```


##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel3)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

#### Comparison 4

For structure selection comparison 1, we are considering all the working correlation structures of *independence*, *exchangeable*, *AR(1)*, *AR(3)*, and "unstructured".

##### Fixed N
In these results, the number of subjects does **NOT** change and stays fixed at `r N[1]`. However, the number of observations for each subject has increases from `r n[fixed_n[1]]` to `r n[fixed_n[length(fixed_n)]]` by 1. Thus, the overall number observations is also increasing.
```{r, echo = FALSE, fig.align = "center", out.width = "100%"}
# Subsetting the results to only include the results focused on fixed N
# simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_n], ", n = ", n[fixed_n])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel4)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```

##### Fixed total number of observations
In these results, the total number of observations does **NOT** change and stays fixed at `r N[fixed_obs[1]] * n[fixed_obs[1]]`. However, the number of subjects and the number of observations for each subject changes. The numbers of subjects are N: `r N[fixed_obs]` while the number of observations for each subjects are n: `r n[fixed_obs]`.
```{r, echo = FALSE, fig.align = "center", out.width = "100%", warning = FALSE}
# Subsetting the results to only include the results focused on fixed total
# number of observations simulations
res_sel <- res_mcic
res_sel$group <- paste0("N = ", res_sel$N, ", n = ", res_sel$n)
group_id <- paste0("N = ", N[fixed_obs], ", n = ", n[fixed_obs])
res_sel <- subset(x = res_sel, subset = group %in% group_id)
res_sel$group <- factor(x = res_sel$group, levels = group_id, ordered = TRUE)
res_sel <- res_sel[order(res_sel$group), ]
res_sel <- split(x = res_sel, f = res_sel$group)
sel <- lapply(
  X = res_sel,
  FUN = function(x) {
    data.frame(
      n = unique(x$group),
      corstr_count(x$sel4)
    )
  }
)
sel <- dplyr::bind_rows(sel)
sel_tab <- knitr::kable(
  x = sel, format = "html",
  col.names = c("N = 200, n =", legend_work_corstr, "Missing"),
  caption = "Selection properties for Fixed N"
)
kableExtra::kable_styling(kable_input = sel_tab, full_width = FALSE)
```