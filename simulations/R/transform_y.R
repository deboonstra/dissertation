# The function of this script file (as of May 2023) is to create a function
# named transform_y that generates the a transformed variant of y that was
# generated by sim_dat.
# The transformation occurs by fitting a saturated model with an unstructured
# working correlation structured and obtaining the inverse of the squared root
# of V. See the notes written on 2023_04_20 and 2023_05_18.

transform_y <- function(data) {
    if (class(data) != "normal") {
        stop("data must be generated from sim_dat.")
    }
    # pulling data
    y <- data$y
    X <- data$X
    id <- data$id
    # initial fit
    # full model with unstructured working correlation structure
    f0 <- geeglm(y ~ X, id = id, corstr = "unstructured")
    geese <- f0$geese
    # obtaining scaled parameter
    phi <- geese$gamma
    # obtaining correlation estimates
    alpha <- geese$alpha
    # creating working correlation matrix
    ra <- diag(1, n)
    index <- lapply(
        gsub("alpha.", "", names(alpha)),
        function(x) {
            hold <- unlist(strsplit(x, split = ":"))
            hold <- as.integer(hold)
            data.frame(i = hold[1], j = hold[2])
        }
    )
    index <- dplyr::bind_rows(index)
    index <- dplyr::bind_rows(
        index,
        data.frame(i = index$j, j = index$i)
    )
    index$corr <- rep(unname(alpha), 2)
    for (i in 1:nrow(index)) {
        ii <- index[i, 1]
        jj <- index[i, 2]
        ra[ii, jj] <- index[i, 3]
    }
    # calculating inverse of the square root of V
    V <- phi * ra
    sqrt_V <- expm::sqrtm(V)
    inv_sqrt_V <- Matrix::solve(sqrt_V)
    inv_sqrt_V <- lapply(seq_len(N), function(x) inv_sqrt_V)
    inv_sqrt_V <- Matrix::bdiag(inv_sqrt_V)
    # final getting transformed y
    yy <- as.matrix(inv_sqrt_V %*% y)
    # returning transform.y object
    class(yy) <- c("transform.y", "matrix")
    return(yy)
}